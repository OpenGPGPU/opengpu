{
    "value": {
        "seenScripts": [
            [
                "/home/runner/work/opengpu/opengpu/depends/hardfloat/common.sc",
                "import mill._\nimport mill.scalalib._\n\ntrait HasChisel\n  extends ScalaModule {\n  // Define these for building chisel from source\n  def chiselModule: Option[ScalaModule]\n\n  override def moduleDeps = super.moduleDeps ++ chiselModule\n\n  def chiselPluginJar: T[Option[PathRef]]\n\n  override def scalacOptions = T(super.scalacOptions() ++ chiselPluginJar().map(path => s\"-Xplugin:${path.path}\"))\n\n  override def scalacPluginClasspath: T[Agg[PathRef]] = T(super.scalacPluginClasspath() ++ chiselPluginJar())\n\n  // Define these for building chisel from ivy\n  def chiselIvy: Option[Dep]\n\n  override def ivyDeps = T(super.ivyDeps() ++ chiselIvy)\n\n  def chiselPluginIvy: Option[Dep]\n\n  override def scalacPluginIvyDeps: T[Agg[Dep]] = T(super.scalacPluginIvyDeps() ++ chiselPluginIvy.map(Agg(_)).getOrElse(Agg.empty[Dep]))\n}\n\ntrait HardfloatModule\n  extends HasChisel\n\ntrait HardfloatTestModule\n  extends TestModule\n    with HasChisel\n    with TestModule.ScalaTest {\n\n  def hardfloatModule: HardfloatModule\n\n  def chiselModule = hardfloatModule.chiselModule\n\n  def chiselPluginJar: T[Option[PathRef]] = T(hardfloatModule.chiselPluginJar())\n\n  def chiselIvy: Option[Dep] = hardfloatModule.chiselIvy\n\n  def chiselPluginIvy: Option[Dep] = hardfloatModule.chiselPluginIvy\n\n  def scalatestIvy: Dep\n\n  def scalaparIvy: Dep\n\n  override def moduleDeps = super.moduleDeps ++ Some(hardfloatModule)\n\n  override def defaultCommandName() = \"test\"\n\n  override def ivyDeps = T(\n    super.ivyDeps() ++ Agg(\n      scalatestIvy,\n      scalaparIvy\n    )\n  )\n}"
            ],
            [
                "/home/runner/work/opengpu/opengpu/common.sc",
                "// SPDX-License-Identifier: Apache-2.0\n// SPDX-FileCopyrightText: 2022 Jiuyang Liu <liu@jiuyang.me>\n// SPDX-FileCopyrightText: 2024 DonaldDuck <vivazsj@gmail.com>\n\nimport mill._\nimport mill.scalalib._\n\ntrait HasChisel extends ScalaModule {\n  // Define these for building chisel from source\n  def chiselModule: Option[ScalaModule]\n\n  override def moduleDeps = super.moduleDeps ++ chiselModule\n\n  def chiselPluginJar: T[Option[PathRef]]\n\n  override def scalacOptions = T(\n    super.scalacOptions() ++ chiselPluginJar().map(path => s\"-Xplugin:${path.path}\") ++ Seq(\"-Ymacro-annotations\")\n  )\n\n  override def scalacPluginClasspath: T[Agg[PathRef]] = T(super.scalacPluginClasspath() ++ chiselPluginJar())\n\n  // Define these for building chisel from ivy\n  def chiselIvy: Option[Dep]\n\n  override def ivyDeps = T(super.ivyDeps() ++ chiselIvy)\n\n  def chiselPluginIvy: Option[Dep]\n\n  override def scalacPluginIvyDeps: T[Agg[Dep]] = T(\n    super.scalacPluginIvyDeps() ++ chiselPluginIvy.map(Agg(_)).getOrElse(Agg.empty[Dep])\n  )\n}\n\ntrait ConfigGenModule extends ScalaModule {\n  def t1Module: ScalaModule\n  def moduleDeps = super.moduleDeps ++ Seq(t1Module)\n  def mainargsIvy: Dep\n  override def ivyDeps = T(super.ivyDeps() ++ Seq(mainargsIvy))\n}\n\ntrait StdlibModule extends ScalaModule with HasChisel {\n  def dwbbModule: ScalaModule\n\n  def moduleDeps = super.moduleDeps ++ Seq(dwbbModule)\n}\n\ntrait HasRVDecoderDB extends ScalaModule {\n  def rvdecoderdbModule: ScalaModule\n  def riscvOpcodesPath:  T[PathRef]\n  def moduleDeps = super.moduleDeps ++ Seq(rvdecoderdbModule)\n  def riscvOpcodesTar:    T[PathRef]      = T {\n    val tmpDir = os.temp.dir()\n    os.makeDir(tmpDir / \"unratified\")\n    os.walk(riscvOpcodesPath().path)\n      .filter(f =>\n        f.baseName.startsWith(\"rv128_\") ||\n          f.baseName.startsWith(\"rv64_\") ||\n          f.baseName.startsWith(\"rv32_\") ||\n          f.baseName.startsWith(\"rv_\") ||\n          f.ext == \"csv\"\n      )\n      .groupBy(_.segments.contains(\"unratified\"))\n      .map {\n        case (true, fs)  => fs.map(os.copy.into(_, tmpDir / \"unratified\"))\n        case (false, fs) => fs.map(os.copy.into(_, tmpDir))\n      }\n    os.proc(\"tar\", \"cf\", T.dest / \"riscv-opcodes.tar\", \".\").call(tmpDir)\n    PathRef(T.dest)\n  }\n  override def resources: T[Seq[PathRef]] = super.resources() ++ Some(riscvOpcodesTar())\n}\n\ntrait RocketvModule extends ScalaModule with HasChisel with HasRVDecoderDB {\n  def arithmeticModule: ScalaModule\n  def hardfloatModule:  ScalaModule\n  def axi4Module:       ScalaModule\n  def stdlibModule:     ScalaModule\n  def moduleDeps = super.moduleDeps ++ Seq(arithmeticModule, hardfloatModule, axi4Module, stdlibModule)\n}\n\ntrait T1Module extends ScalaModule with HasChisel with HasRVDecoderDB {\n  def arithmeticModule: ScalaModule\n  def hardfloatModule:  ScalaModule\n  def axi4Module:       ScalaModule\n  def stdlibModule:     ScalaModule\n  def moduleDeps = super.moduleDeps ++ Seq(arithmeticModule, hardfloatModule, axi4Module, stdlibModule)\n}\n\ntrait OGPUModule extends ScalaModule with HasChisel with HasRVDecoderDB {\n  def arithmeticModule: ScalaModule\n  def hardfloatModule:  ScalaModule\n  def axi4Module:       ScalaModule\n  def stdlibModule:     ScalaModule\n  def T1Module:         ScalaModule\n  def RocketvModule:    ScalaModule\n  def cdeModule:        ScalaModule\n  def diplomacyModule:        ScalaModule\n  def rocketchipModule:        ScalaModule\n\n  def moduleDeps = super.moduleDeps ++ Seq(arithmeticModule, hardfloatModule, axi4Module, stdlibModule, T1Module, cdeModule, diplomacyModule, rocketchipModule, RocketvModule)\n}\n"
            ],
            [
                "/home/runner/work/opengpu/opengpu/depends/diplomacy/common.sc",
                "import mill._\nimport mill.scalalib._\n\ntrait HasChisel extends ScalaModule {\n  // Define these for building chisel from source\n  def chiselModule: Option[ScalaModule]\n  override def moduleDeps = super.moduleDeps ++ chiselModule\n\n  def chiselPluginJar: T[Option[PathRef]]\n  override def scalacOptions = T(\n    (super.scalacOptions() ++ chiselPluginJar().map(path => s\"-Xplugin:${path.path}\")) ++ Seq(\"-deprecation\", \"-feature\")\n  )\n  override def scalacPluginClasspath: T[Agg[PathRef]] = T(super.scalacPluginClasspath() ++ chiselPluginJar())\n\n  // Define these for using chisel from ivy\n  def chiselIvy: Option[Dep]\n  override def ivyDeps = T(super.ivyDeps() ++ chiselIvy)\n\n  def chiselPluginIvy: Option[Dep]\n  override def scalacPluginIvyDeps: T[Agg[Dep]] = T(\n    super.scalacPluginIvyDeps() ++ chiselPluginIvy.map(Agg(_)).getOrElse(Agg.empty[Dep])\n  )\n}\n\ntrait DiplomacyModule extends HasChisel {\n\n  def cdeModule: ScalaModule\n\n  override def moduleDeps = super.moduleDeps ++ Some(cdeModule)\n\n  def sourcecodeIvy: Dep\n\n  override def ivyDeps = T(super.ivyDeps() ++ Some(sourcecodeIvy))\n\n  override def scalacOptions = T(\n    super.scalacOptions() ++ Seq(\"-Wunused\")\n  )\n\n}\n"
            ],
            [
                "/home/runner/work/opengpu/opengpu/depends/rocket-chip/common.sc",
                "import mill._\nimport mill.scalalib._\n\ntrait HasChisel\n  extends ScalaModule {\n  // Define these for building chisel from source\n  def chiselModule: Option[ScalaModule]\n\n  override def moduleDeps = super.moduleDeps ++ chiselModule\n\n  def chiselPluginJar: T[Option[PathRef]]\n\n  override def scalacOptions = T(super.scalacOptions() ++ chiselPluginJar().map(path => s\"-Xplugin:${path.path}\"))\n\n  override def scalacPluginClasspath: T[Agg[PathRef]] = T(super.scalacPluginClasspath() ++ chiselPluginJar())\n\n  // Define these for building chisel from ivy\n  def chiselIvy: Option[Dep]\n\n  override def ivyDeps = T(super.ivyDeps() ++ chiselIvy)\n\n  def chiselPluginIvy: Option[Dep]\n\n  override def scalacPluginIvyDeps: T[Agg[Dep]] = T(super.scalacPluginIvyDeps() ++ chiselPluginIvy.map(Agg(_)).getOrElse(Agg.empty[Dep]))\n}\n\ntrait MacrosModule\n  extends ScalaModule {\n\n  def scalaReflectIvy: Dep\n\n  override def ivyDeps = T(super.ivyDeps() ++ Some(scalaReflectIvy))\n}\n\n\ntrait RocketChipModule\n  extends HasChisel {\n  override def mainClass = T(Some(\"freechips.rocketchip.diplomacy.Main\"))\n\n  def macrosModule: MacrosModule\n\n  // should be hardfloat/common.sc#HardfloatModule\n  def hardfloatModule: ScalaModule\n\n  def diplomacyModule: ScalaModule\n\n  def mainargsIvy: Dep\n\n  def json4sJacksonIvy: Dep\n\n  override def moduleDeps = super.moduleDeps ++ Seq(macrosModule, hardfloatModule, diplomacyModule)\n\n  override def ivyDeps = T(\n    super.ivyDeps() ++ Agg(\n      mainargsIvy,\n      json4sJacksonIvy,\n    )\n  )\n}\n"
            ],
            [
                "/home/runner/work/opengpu/opengpu/depends/cde/common.sc",
                "import mill._\nimport scalalib._\n\ntrait CDEModule\n  extends ScalaModule\n\ntrait CDETestModule\n  extends TestModule\n    with ScalaModule\n    with TestModule.Utest {\n\n  def cdeModule: CDEModule\n\n  def utestIvy: Dep\n\n  override def moduleDeps = super.moduleDeps ++ Some(cdeModule)\n\n  override def ivyDeps = T(\n    super.ivyDeps() ++ Agg(\n      utestIvy\n    )\n  )\n\n  override def defaultCommandName() = \"test\"\n}\n"
            ],
            [
                "/home/runner/work/opengpu/opengpu/build.sc",
                "// SPDX-License-Identifier: Apache-2.0\n// SPDX-FileCopyrightText: 2022 Jiuyang Liu <liu@jiuyang.me>\n// SPDX-FileCopyrightText: 2024 DonaldDuck <vivazsj@gmail.com>\n\n// import mill._\n// import scalalib._\n// import scalalib.scalafmt._\n// import mill.scalalib.TestModule.ScalaTest\nimport mill._\nimport mill.scalalib._\nimport mill.scalalib.publish._\nimport mill.scalalib.scalafmt._\n\n// import mill.scalalib._\n// import mill.define.{Command, TaskModule}\n// import mill.scalalib.publish._\n// import mill.scalalib.scalafmt._\nimport mill.util.Jvm\nimport coursier.maven.MavenRepository\nimport millbuild.depends.chisel.build\nimport millbuild.depends.arithmetic.common\nimport millbuild.depends.`chisel-interface`.common\nimport millbuild.depends.hardfloat.common\nimport millbuild.depends.rvdecoderdb.common\nimport millbuild.depends.`rocket-chip`.common\nimport millbuild.depends.cde.common\nimport millbuild.depends.diplomacy.common\nimport _root_._\n\nobject v {\n  val scala    = \"2.13.15\"\n  val mainargs = ivy\"com.lihaoyi::mainargs:0.5.0\"\n  val sourcecode = ivy\"com.lihaoyi::sourcecode:0.3.1\"\n  val oslib    = ivy\"com.lihaoyi::os-lib:0.9.1\"\n  val upickle  = ivy\"com.lihaoyi::upickle:3.3.1\"\n  val spire    = ivy\"org.typelevel::spire:latest.integration\"\n  val evilplot = ivy\"io.github.cibotech::evilplot:latest.integration\"\n  val scalaReflect = ivy\"org.scala-lang:scala-reflect:${scala}\"\n}\n\nobject chisel extends Chisel\n\ntrait Chisel extends millbuild.depends.chisel.build.Chisel {\n  def crossValue              = v.scala\n  override def millSourcePath = os.pwd / \"depends\" / \"chisel\"\n}\n\nobject macros extends Macros\n\ntrait Macros\n  extends millbuild.depends.`rocket-chip`.common.MacrosModule\n    with ScalaModule {\n\n  def scalaVersion: T[String] = T(v.scala)\n\n  def scalaReflectIvy = v.scalaReflect\n}\n\nobject arithmetic extends Arithmetic\n\ntrait Arithmetic extends millbuild.depends.arithmetic.common.ArithmeticModule {\n  override def millSourcePath = os.pwd / \"depends\" / \"arithmetic\" / \"arithmetic\"\n  def scalaVersion            = T(v.scala)\n\n  def chiselModule    = Some(chisel)\n  def chiselPluginJar = T(Some(chisel.pluginModule.jar()))\n  def chiselIvy       = None\n  def chiselPluginIvy = None\n\n  def spireIvy:    T[Dep] = v.spire\n  def evilplotIvy: T[Dep] = v.evilplot\n}\n\nobject axi4 extends AXI4\n\ntrait AXI4 extends millbuild.depends.`chisel-interface`.common.AXI4Module {\n  override def millSourcePath = os.pwd / \"depends\" / \"chisel-interface\" / \"axi4\"\n  def scalaVersion            = v.scala\n\n  def mainargsIvy = v.mainargs\n\n  def chiselModule    = Some(chisel)\n  def chiselPluginJar = T(Some(chisel.pluginModule.jar()))\n  def chiselIvy       = None\n  def chiselPluginIvy = None\n}\n\nobject hardfloat extends Hardfloat\n\ntrait Hardfloat extends millbuild.depends.`hardfloat`.common.HardfloatModule {\n  override def millSourcePath = os.pwd / \"depends\" / \"hardfloat\" / \"hardfloat\"\n  def scalaVersion            = T(v.scala)\n\n  def chiselModule    = Some(chisel)\n  def chiselPluginJar = T(Some(chisel.pluginModule.jar()))\n  def chiselIvy       = None\n  def chiselPluginIvy = None\n}\n\nobject rvdecoderdb extends RVDecoderDB\n\ntrait RVDecoderDB extends millbuild.depends.rvdecoderdb.common.RVDecoderDBJVMModule with ScalaModule {\n  def scalaVersion            = T(v.scala)\n  def osLibIvy                = v.oslib\n  def upickleIvy              = v.upickle\n  override def millSourcePath = os.pwd / \"depends\" / \"rvdecoderdb\" / \"rvdecoderdb\"\n}\n\nobject dwbb extends DWBB\n\ntrait DWBB extends millbuild.depends.`chisel-interface`.common.DWBBModule {\n  override def millSourcePath = os.pwd / \"depends\" / \"chisel-interface\" / \"dwbb\"\n  def scalaVersion            = v.scala\n\n  def mainargsIvy = v.mainargs\n\n  def chiselModule    = Some(chisel)\n  def chiselPluginJar = T(Some(chisel.pluginModule.jar()))\n  def chiselIvy       = None\n  def chiselPluginIvy = None\n}\n\n\nobject stdlib extends Stdlib\n\ntrait Stdlib extends millbuild.common.StdlibModule with ScalafmtModule {\n  override def millSourcePath = os.pwd / \"depends\" / \"t1\" / \"stdlib\"\n  def scalaVersion = v.scala\n\n  def mainargsIvy = v.mainargs\n\n  def dwbbModule: ScalaModule = dwbb\n\n  def chiselModule    = Some(chisel)\n  def chiselPluginJar = T(Some(chisel.pluginModule.jar()))\n  def chiselIvy       = None\n  def chiselPluginIvy = None\n}\n\nobject rocketv extends Rocketv\n\ntrait Rocketv extends millbuild.common.RocketvModule with ScalafmtModule {\n  override def millSourcePath = os.pwd / \"depends\" / \"t1\" / \"rocketv\"\n  def scalaVersion = T(v.scala)\n\n  def arithmeticModule  = arithmetic\n  def axi4Module        = axi4\n  def hardfloatModule   = hardfloat\n  def stdlibModule      = stdlib\n  def rvdecoderdbModule = rvdecoderdb\n  def riscvOpcodesPath  = T.input(PathRef(os.pwd / \"depends\" / \"riscv-opcodes\"))\n\n  def chiselModule    = Some(chisel)\n  def chiselPluginJar = T(Some(chisel.pluginModule.jar()))\n  def chiselIvy       = None\n  def chiselPluginIvy = None\n}\n\n\nobject t1 extends T1\n\ntrait T1 extends millbuild.common.T1Module with ScalafmtModule {\n  override def millSourcePath = os.pwd / \"depends\" / \"t1\" / \"t1\"\n  def scalaVersion = T(v.scala)\n\n  def arithmeticModule  = arithmetic\n  def axi4Module        = axi4\n  def hardfloatModule   = hardfloat\n  def rvdecoderdbModule = rvdecoderdb\n  def stdlibModule      = stdlib\n  def riscvOpcodesPath  = T.input(PathRef(os.pwd / \"depends\" / \"riscv-opcodes\"))\n\n  def chiselModule    = Some(chisel)\n  def chiselPluginJar = T(Some(chisel.pluginModule.jar()))\n  def chiselIvy       = None\n  def chiselPluginIvy = None\n}\n\nobject cde extends CDE\n\ntrait CDE\n  extends millbuild.depends.cde.common.CDEModule  with ScalaModule {\n  override def millSourcePath = os.pwd / \"depends\" / \"cde\" / \"cde\"\n\n  def scalaVersion: T[String] = T(v.scala)\n\n}\n\nobject diplomacy extends Diplomacy\n\ntrait Diplomacy\n    extends millbuild.depends.diplomacy.common.DiplomacyModule {\n\n  override def scalaVersion: T[String] = T(v.scala)\n\n  override def millSourcePath = os.pwd / \"depends\" / \"diplomacy\" / \"diplomacy\"\n  def sourcecodeIvy = v.sourcecode\n\n\n  def chiselModule    = Some(chisel)\n  def chiselPluginJar = T(Some(chisel.pluginModule.jar()))\n  def chiselIvy       = None\n  def chiselPluginIvy = None\n\n  def cdeModule = cde\n}\n\nobject rocketchip extends RocketChip\n\ntrait RocketChip\n  extends millbuild.depends.`rocket-chip`.common.RocketChipModule\n    with SbtModule {\n  def scalaVersion: T[String] = T(v.scala)\n  def sourcecodeIvy = v.sourcecode\n  def mainargsIvy = v.mainargs\n\n  override def millSourcePath = os.pwd / \"depends\" / \"rocket-chip\"\n\n  def chiselModule    = Some(chisel)\n  def chiselPluginJar = T(Some(chisel.pluginModule.jar()))\n  def chiselIvy       = None\n  def chiselPluginIvy = None\n\n  def hardfloatModule = hardfloat\n\n  def cdeModule = cde\n\n  def macrosModule = macros\n\n  def diplomacyModule = diplomacy\n\n  def diplomacyIvy = None\n\n\n  def json4sJacksonIvy = ivy\"org.json4s::json4s-jackson:4.0.5\"\n}\n\nobject ogpu extends OGPU\n\ntrait OGPU extends millbuild.common.OGPUModule with ScalafmtModule with SbtModule {\n  override def millSourcePath = os.pwd\n  def scalaVersion            = v.scala\n\n  def arithmeticModule  = arithmetic\n  def axi4Module        = axi4\n  def hardfloatModule   = hardfloat\n  def rvdecoderdbModule = rvdecoderdb\n  def stdlibModule      = stdlib\n  def T1Module          = t1\n  def RocketvModule     = rocketv\n  def cdeModule         = cde\n  def diplomacyModule   = diplomacy\n  def rocketchipModule  = rocketchip\n\n  def riscvOpcodesPath  = T.input(PathRef(os.pwd / \"depends\" / \"riscv-opcodes\"))\n\n  def chiselModule    = Some(chisel)\n  def chiselPluginJar = T(Some(chisel.pluginModule.jar()))\n  def chiselIvy       = None\n  def chiselPluginIvy = None\n\n  override def sources = T.sources {\n    super.sources() ++ Seq(PathRef(this.millSourcePath / \"src\"))\n  }\n  def lineCount = T {\n    this.sources().filter(ref => os.exists(ref.path)).flatMap(ref => os.walk(ref.path)).filter(os.isFile).flatMap(os.read.lines).size\n  }\n\n  def printLineCount() = T.command {\n    println(s\"Lines of code(LOC): ${lineCount()} !!!\")\n  }\n\n  object test extends SbtModuleTests\n    with TestModule.ScalaTest\n    with ScalafmtModule {\n\n    override def forkArgs = Seq(\"-Xmx8G\", \"-Xss256m\")\n\n    override def sources = T.sources {\n      super.sources() ++ Seq(PathRef(this.millSourcePath / \"test\"))\n    }\n    override def ivyDeps = super.ivyDeps() ++ Agg(\n      ivy\"org.scalatest::scalatest:3.2.17\"\n    )\n  }\n}\n"
            ],
            [
                "/home/runner/work/opengpu/opengpu/depends/chisel/build.sc",
                "import mill._\nimport mill.scalalib._\nimport mill.scalalib.publish._\nimport mill.scalalib.scalafmt._\nimport mill.api.Result\nimport mill.define.Cross\nimport mill.scalalib.api.ZincWorkerUtil.matchingVersions\nimport mill.util.Jvm.createJar\nimport _root_._\nimport mill.contrib.jmh.JmhModule\nimport _root_._\nimport io.kipp.mill.ci.release.{CiReleaseModule, SonatypeHost}\nimport de.tobiasroeser.mill.vcs.version.VcsVersion // pulled in by mill-ci-release\n\nimport _root_._\n\nobject v extends Module {\n\n  val javaVersion = {\n    val rawVersion = sys.props(\"java.specification.version\")\n    // Older versions of Java started with 1., e.g. 1.8 == 8\n    rawVersion.stripPrefix(\"1.\").toInt\n  }\n\n  val firtoolVersion = {\n    val j = _root_.upickle.default.read[Map[String, String]](os.read(millSourcePath / os.up / \"etc\" / \"circt.json\"))\n    j(\"version\").stripPrefix(\"firtool-\")\n  }\n  // Java 21 only works with 2.13.11+, but Project Panama uses Java 21\n  // Only publish plugin for 2.13.11+ when using Java > 11, but still\n  // publish all versions when Java version <= 11.\n  val pluginScalaCrossVersions = {\n    val latest213 = 15\n    val java21Min213 = 11\n    val minVersion = if (javaVersion > 11) java21Min213 else 0\n    val versions = minVersion to latest213\n    val versionSeq = versions.map(v => s\"2.13.$v\").toSeq\n    versionSeq ++ Seq(\"3.3.4\")\n  }\n\n  val scalaCrossVersions = Seq(\n    \"2.13.15\",\n    \"3.3.4\"\n  )\n\n  def isScala3(ver: String): Boolean = ver.startsWith(\"3.\")\n\n  def buildUnits(): Seq[ScalaModule] = {\n    scalaCrossVersions.flatMap { ver =>\n      Seq(chisel(ver), stdlib(ver), unipublish)\n    } ++ scalaCrossVersions.filterNot(isScala3(_)).flatMap { ver2 =>\n      Seq(\n        chisel(ver2).test,\n        firrtl(ver2).test,\n        svsim(ver2).test,\n        integrationTests(ver2).test,\n        litutility(ver2),\n        panamaconverter(ver2),\n        panamalib(ver2),\n        panamaom(ver2)\n      )\n    }\n  }\n\n  val scalaVersion = scalaCrossVersions.head\n  val jmhVersion = \"1.37\"\n  val osLib = ivy\"com.lihaoyi::os-lib:0.10.0\"\n  val upickle = ivy\"com.lihaoyi::upickle:3.3.1\"\n  val firtoolResolver = ivy\"org.chipsalliance::firtool-resolver:2.0.0\"\n  val scalatest = ivy\"org.scalatest::scalatest:3.2.19\"\n  val scalacheck = ivy\"org.scalatestplus::scalacheck-1-18:3.2.19.0\"\n  val json4s = ivy\"org.json4s::json4s-native:4.0.7\"\n  val dataclass = ivy\"io.github.alexarchambault::data-class:0.2.6\"\n  val commonText = ivy\"org.apache.commons:commons-text:1.12.0\"\n  val scopt = ivy\"com.github.scopt::scopt:4.1.0\"\n\n  def scalaReflect(scalaVersion:  String) = ivy\"org.scala-lang:scala-reflect:$scalaVersion\"\n  def scalaCompiler(scalaVersion: String) = ivy\"org.scala-lang:scala-compiler:$scalaVersion\"\n  def scalaLibrary(scalaVersion:  String) = ivy\"org.scala-lang:scala-library:$scalaVersion\"\n\n  def circt(version: String, os: String, platform: String) =\n    s\"https://github.com/llvm/circt/releases/download/firtool-${version}/circt-full-shared-${os}-${platform}.tar.gz\"\n\n  val scala2WarnConf = Seq(\n    \"msg=APIs in chisel3.internal:s\",\n    \"msg=Importing from firrtl:s\",\n    \"msg=migration to the MLIR:s\",\n    \"msg=method hasDefiniteSize in trait IterableOnceOps is deprecated:s\", // replacement `knownSize` is not in 2.12\n    \"msg=object JavaConverters in package collection is deprecated:s\",\n    \"msg=undefined in comment for method cf in class PrintableHelper:s\",\n    // This is deprecated for external users but not internal use\n    \"cat=deprecation&origin=firrtl\\\\.options\\\\.internal\\\\.WriteableCircuitAnnotation:s\",\n    \"cat=deprecation&origin=chisel3\\\\.util\\\\.experimental\\\\.BoringUtils.*:s\",\n    \"cat=deprecation&origin=chisel3\\\\.experimental\\\\.IntrinsicModule:s\",\n    \"cat=deprecation&origin=chisel3\\\\.ltl.*:s\",\n    // Deprecated for external users, will eventually be removed.\n    \"cat=deprecation&msg=Looking up Modules is deprecated:s\",\n    // Only for testing of deprecated APIs\n    \"cat=deprecation&msg=Use of @instantiable on user-defined types is deprecated:s\"\n  )\n\n  // ScalacOptions\n  val scala2CommonOptions = Seq(\n    \"-deprecation\",\n    \"-feature\",\n    \"-unchecked\",\n    \"-Werror\",\n    \"-Ymacro-annotations\",\n    \"-explaintypes\",\n    \"-Xcheckinit\",\n    \"-Xlint:infer-any\",\n    \"-Xlint:missing-interpolator\",\n    \"-language:reflectiveCalls\",\n    s\"-Wconf:${scala2WarnConf.mkString(\",\")}\"\n  )\n}\n\ndef compileAll() = T.command {\n  T.traverse(v.buildUnits())(_.compile)()\n}\n\ntrait ChiselPublishModule extends CiReleaseModule {\n  // Publish information\n  def pomSettings = PomSettings(\n    description = artifactName(),\n    organization = \"org.chipsalliance\",\n    url = \"https://www.chisel-lang.org\",\n    licenses = Seq(License.`Apache-2.0`),\n    versionControl = VersionControl.github(\"chipsalliance\", \"chisel\"),\n    developers = Seq(\n      Developer(\"jackkoenig\", \"Jack Koenig\", \"https://github.com/jackkoenig\"),\n      Developer(\"azidar\", \"Adam Izraelevitz\", \"https://github.com/azidar\"),\n      Developer(\"seldridge\", \"Schuyler Eldridge\", \"https://github.com/seldridge\")\n    )\n  )\n\n  override def sonatypeHost = Some(SonatypeHost.s01)\n\n  override def publishVersion = VcsVersion\n    .vcsState()\n    .format(\n      countSep = \"+\",\n      revHashDigits = 8,\n      untaggedSuffix = \"-SNAPSHOT\"\n    )\n\n}\n\ntrait HasScala2MacroAnno extends CrossModuleBase {\n  override def scalacOptions = T {\n    if (!v.isScala3(crossScalaVersion)) {\n      super.scalacOptions() ++ Agg(\"-Ymacro-annotations\")\n    } else super.scalacOptions()\n  }\n}\n\ntrait HasScala2Plugin extends CrossModuleBase {\n  def pluginModule: Plugin\n\n  override def scalacOptions = T {\n    if (!v.isScala3(crossScalaVersion)) {\n      super.scalacOptions() ++ Agg(s\"-Xplugin:${pluginModule.jar().path}\")\n    } else super.scalacOptions()\n  }\n\n  override def scalacPluginClasspath = T {\n    if (!v.isScala3(crossScalaVersion)) {\n      super.scalacPluginClasspath() ++ Agg(pluginModule.jar())\n    } else super.scalacPluginClasspath()\n  }\n}\n\nobject firrtl extends Cross[Firrtl](v.scalaCrossVersions)\n\ntrait Firrtl extends CrossSbtModule with Cross.Module[String] with HasScala2MacroAnno with ScalafmtModule {\n  def millSourcePath = super.millSourcePath / os.up / \"firrtl\"\n  def scalaVersion = crossScalaVersion\n\n  override def scalacOptions = T {\n    if (v.isScala3(crossScalaVersion)) {\n      Seq.empty[String]\n    } else {\n      v.scala2CommonOptions ++ Seq(\n        \"-language:reflectiveCalls\",\n        \"-language:existentials\",\n        \"-language:implicitConversions\",\n        \"-Yrangepos\", // required by SemanticDB compiler plugin\n        \"-Xsource:3\",\n        \"-Xsource-features:infer-override\"\n      )\n    }\n  }\n\n  val commonDeps = Agg(\n    v.scopt,\n    v.commonText,\n    v.osLib,\n    v.json4s\n  )\n\n  def ivyDeps = if (v.isScala3(crossScalaVersion)) {\n    commonDeps\n  } else {\n    commonDeps ++ Agg(v.dataclass)\n  }\n\n  object test extends SbtModuleTests with TestModule.ScalaTest with ScalafmtModule {\n    def ivyDeps = Agg(v.scalatest, v.scalacheck)\n  }\n}\n\nobject svsim extends Cross[Svsim](v.scalaCrossVersions)\ntrait Svsim extends CrossSbtModule with ScalafmtModule {\n  def millSourcePath = super.millSourcePath / os.up / \"svsim\"\n\n  override def scalacOptions = T {\n    if (v.isScala3(crossScalaVersion)) {\n      Seq.empty[String]\n    } else {\n      v.scala2CommonOptions ++ Seq(\n        \"-Xsource:3\",\n        \"-Xsource-features:case-apply-copy-access\"\n      )\n    }\n  }\n\n  object test extends SbtModuleTests with TestModule.ScalaTest with ScalafmtModule {\n    def ivyDeps = Agg(v.scalatest, v.scalacheck)\n  }\n}\n\nobject macros extends Cross[Macros](v.scalaCrossVersions)\ntrait Macros extends CrossSbtModule with HasScala2MacroAnno with ScalafmtModule {\n  def millSourcePath = super.millSourcePath / os.up / \"macros\"\n\n  override def scalacOptions = T {\n    if (v.isScala3(crossScalaVersion)) {\n      Seq.empty[String]\n    } else {\n      v.scala2CommonOptions ++ Seq(\n        \"-Xsource:3\"\n      )\n    }\n  }\n\n  override def ivyDeps = super.ivyDeps() ++ Seq(v.scalaReflect(crossScalaVersion))\n}\n\nobject core extends Cross[Core](v.scalaCrossVersions)\ntrait Core extends CrossSbtModule with HasScala2MacroAnno with ScalafmtModule {\n  def scalaVersion = crossScalaVersion\n  def millSourcePath = super.millSourcePath / os.up / \"core\"\n\n  override def scalacOptions = T {\n    if (v.isScala3(crossScalaVersion)) {\n      Seq.empty[String]\n    } else {\n      v.scala2CommonOptions ++ Seq(\n        \"-Xsource:3\"\n      )\n    }\n  }\n\n  val crossModuleDeps = Seq(firrtl(crossScalaVersion)) ++ {\n    if (v.isScala3(crossScalaVersion)) Seq.empty\n    else Seq(macros(crossScalaVersion))\n  }\n\n  override def moduleDeps = super.moduleDeps ++ crossModuleDeps\n\n  val commonDeps = Agg(\n    v.osLib,\n    v.upickle\n  )\n\n  override def ivyDeps = if (v.isScala3(crossScalaVersion)) {\n    super.ivyDeps() ++ commonDeps ++ Agg(v.firtoolResolver.withDottyCompat(scalaVersion()))\n  } else {\n    super.ivyDeps() ++ commonDeps ++ Agg(v.firtoolResolver)\n  }\n\n  // Similar to the publish version, but no dirty indicators because otherwise\n  // this file will change any time any file is changed.\n  def publishVersion = T {\n    VcsVersion\n      .vcsState()\n      .format(\n        countSep = \"+\",\n        revHashDigits = 8,\n        untaggedSuffix = \"-SNAPSHOT\",\n        dirtySep = \"\",\n        dirtyHashDigits = 0\n      )\n  }\n  def buildInfo = T {\n    val outputFile = T.dest / \"chisel3\" / \"BuildInfo.scala\"\n    val firtoolVersionString = \"Some(\\\"\" + v.firtoolVersion + \"\\\")\"\n    val contents =\n      s\"\"\"\n         |package chisel3\n         |case object BuildInfo {\n         |  val buildInfoPackage: String = \"chisel3\"\n         |  val version: String = \"${publishVersion()}\"\n         |  val scalaVersion: String = \"${scalaVersion()}\"\n         |  @deprecated(\"Chisel no longer uses SBT, this field will be removed.\", \"Chisel 7.0\")\n         |  val sbtVersion: String = \"\"\n         |  val firtoolVersion: scala.Option[String] = $firtoolVersionString\n         |  override val toString: String = {\n         |    \"buildInfoPackage: %s, version: %s, scalaVersion: %s, firtoolVersion %s\".format(\n         |        buildInfoPackage, version, scalaVersion, firtoolVersion\n         |    )\n         |  }\n         |}\n         |\"\"\".stripMargin\n    os.write(outputFile, contents, createFolders = true)\n    PathRef(T.dest)\n  }\n  override def generatedSources = T {\n    super.generatedSources() :+ buildInfo()\n  }\n}\n\nobject plugin extends Cross[Plugin](v.pluginScalaCrossVersions)\ntrait Plugin extends CrossSbtModule with ScalafmtModule with ChiselPublishModule {\n  override def artifactName = \"chisel-plugin\"\n\n  // The plugin is compiled for every minor Scala version\n  override def crossFullScalaVersion = true\n\n  def millSourcePath = super.millSourcePath / os.up / \"plugin\"\n  def scalaLibraryIvy = v.scalaLibrary(crossScalaVersion)\n  def scalaReflectIvy = v.scalaReflect(crossScalaVersion)\n  def scalaCompilerIvy: Dep = v.scalaCompiler(crossScalaVersion)\n\n  def ivyDeps = T {\n    if (!v.isScala3(crossScalaVersion)) {\n      super.ivyDeps() ++ Agg(scalaLibraryIvy, scalaReflectIvy, scalaCompilerIvy)\n    } else {\n      super.ivyDeps()\n    }\n  }\n}\n\nobject chisel extends Cross[Chisel](v.scalaCrossVersions)\ntrait Chisel extends CrossSbtModule with HasScala2MacroAnno with HasScala2Plugin with ScalafmtModule {\n  override def millSourcePath = super.millSourcePath / os.up\n  def svsimModule = svsim(crossScalaVersion)\n  def coreModule = core(crossScalaVersion)\n  def pluginModule = plugin()\n\n  override def scalacOptions = T {\n    if (v.isScala3(crossScalaVersion)) {\n      Seq.empty[String]\n    } else {\n      super.scalacOptions() ++ v.scala2CommonOptions\n    }\n  }\n\n  override def moduleDeps = super.moduleDeps ++ Seq(coreModule, svsimModule)\n\n  object test extends SbtModuleTests with TestModule.ScalaTest with ScalafmtModule {\n    def ivyDeps = Agg(v.scalatest, v.scalacheck)\n\n    // Suppress Scala 3 behavior requiring explicit types on implicit definitions\n    // Note this must come before the -Wconf is warningSuppression\n    override def scalacOptions = T { super.scalacOptions() :+ \"-Wconf:cat=other-implicit-type:s\" }\n  }\n}\n\nobject integrationTests extends Cross[IntegrationTests](v.scalaCrossVersions)\ntrait IntegrationTests extends CrossSbtModule with HasScala2Plugin with ScalafmtModule {\n  def pluginModule = plugin()\n  def millSourcePath = os.pwd / \"integration-tests\"\n\n  object test extends SbtModuleTests with TestModule.ScalaTest with ScalafmtModule {\n    override def moduleDeps = super.moduleDeps :+ chisel().test\n    def ivyDeps = Agg(v.scalatest, v.scalacheck)\n  }\n}\n\nobject stdlib extends Cross[Stdlib](v.scalaCrossVersions)\ntrait Stdlib extends CrossSbtModule with HasScala2Plugin with ScalafmtModule {\n  def millSourcePath = super.millSourcePath / os.up / \"stdlib\"\n  def chiselModule = chisel(crossScalaVersion)\n  def pluginModule = plugin(crossScalaVersion)\n\n  override def moduleDeps = Seq(chiselModule, pluginModule)\n}\n\nobject circtpanamabinding extends CIRCTPanamaBinding\n\ntrait CIRCTPanamaBinding extends panama.CIRCTPanamaBindingModule {\n  def header = T(PathRef(millSourcePath / \"jextract-headers.h\"))\n  def circtInstallPath = T(panama.utils.circtInstallDir())\n  def jextractBinary = T(panama.utils.jextractInstallDir() / \"bin\" / \"jextract\")\n  def includePaths = T(Seq(PathRef(circtInstallPath() / \"include\")))\n  def libraryPaths = T(Seq(PathRef(circtInstallPath() / \"lib\")))\n}\n\nobject panamalib extends Cross[PanamaLib](v.scalaCrossVersions)\n\ntrait PanamaLib extends panama.PanamaLibModule with CrossModuleBase with ScalafmtModule {\n  def circtPanamaBindingModule = circtpanamabinding\n}\n\nobject panamaom extends Cross[PanamaOM](v.scalaCrossVersions)\n\ntrait PanamaOM extends panama.PanamaOMModule with CrossModuleBase with ScalafmtModule {\n  def panamaLibModule = panamalib(crossScalaVersion)\n}\n\nobject panamaconverter extends Cross[PanamaConverter](v.scalaCrossVersions)\n\ntrait PanamaConverter\n    extends panama.PanamaConverterModule\n    with CrossModuleBase\n    with HasScala2Plugin\n    with ScalafmtModule {\n  def panamaOMModule = panamaom(crossScalaVersion)\n  def chiselModule = chisel(crossScalaVersion)\n  def pluginModule = plugin(crossScalaVersion)\n\n  override def moduleDeps = super.moduleDeps ++ Some(chiselModule)\n}\n\nobject litutility extends Cross[LitUtility](v.scalaCrossVersions)\n\ntrait LitUtility extends panama.LitUtilityModule with CrossModuleBase with HasScala2Plugin with ScalafmtModule {\n  def chiselModule = chisel(crossScalaVersion)\n  def pluginModule = plugin(crossScalaVersion)\n  def millSourcePath = super.millSourcePath / os.up / \"lit\" / \"utility\"\n  def panamaConverterModule = panamaconverter(crossScalaVersion)\n  def panamaOMModule = panamaom(crossScalaVersion)\n\n  override def moduleDeps = super.moduleDeps ++ Some(chiselModule)\n}\n\nobject lit extends Cross[Lit](v.scalaCrossVersions)\n\ntrait Lit extends panama.LitModule with Cross.Module[String] {\n  def scalaVersion: T[String] = crossValue\n  def runClasspath: T[Seq[os.Path]] = T(litutility(crossValue).runClasspath().map(_.path))\n  def pluginJars:   T[Seq[os.Path]] = T(Seq(litutility(crossValue).panamaConverterModule.pluginModule.jar().path))\n  def javaLibraryPath: T[Seq[os.Path]] = T(\n    litutility(crossValue).panamaConverterModule.circtPanamaBindingModule.libraryPaths().map(_.path)\n  )\n  def javaHome:     T[os.Path] = T(os.Path(sys.props(\"java.home\")))\n  def chiselLitDir: T[os.Path] = T(millSourcePath)\n  def litConfigIn:  T[PathRef] = T.source(millSourcePath / \"tests\" / \"lit.site.cfg.py.in\")\n}\n\nobject benchmark extends ScalaModule with JmhModule with ScalafmtModule {\n  def scalaVersion = v.scalaVersion\n  def jmhCoreVersion = v.jmhVersion\n\n  override def moduleDeps = Seq(chisel(v.scalaVersion))\n}\n\n/** Aggregate project for publishing Chisel as a single artifact\n  */\nobject unipublish extends ScalaModule with ChiselPublishModule {\n\n  def scalaVersion = v.scalaVersion\n\n  // This is published as chisel\n  override def artifactName = \"chisel\"\n\n  // Older versions of Scala do not work with newer versions of the JVM\n  // This is a hack to ensure we always use Java 8 to publish Chisel with Scala 2.13\n  // We could use Java 11 with -release 8\n  // Note that this target is used by real publishing but not by publishLocal\n  override def publishArtifacts = T {\n    // TODO when we publish for Scala 3, only do this check for Scala 2.13\n    if (v.javaVersion != 8) {\n      throw new Exception(s\"Publishing requires Java 8, current JDK is ${v.javaVersion}\")\n    }\n    super.publishArtifacts\n  }\n\n  /** Publish both this project and the plugin (for the default Scala version) */\n  override def publishLocal(localIvyRepo: String = null) = T.command {\n    // TODO consider making this parallel and publishing all cross-versions for plugin\n    plugin(v.scalaVersion).publishLocal(localIvyRepo)()\n    super.publishLocal(localIvyRepo)()\n  }\n\n  // Explicitly not using moduleDeps because that influences so many things\n  def components = Seq(firrtl, svsim, macros, core, chisel).map(_(v.scalaVersion))\n\n  /** Aggregated ivy deps to include as dependencies in POM */\n  def ivyDeps = T { T.traverse(components)(_.ivyDeps)().flatten }\n\n  /** Aggregated local classpath to include in jar */\n  override def localClasspath = T { T.traverse(components)(_.localClasspath)().flatten }\n\n  /** Aggreagted sources from all component modules */\n  def aggregatedSources = T { T.traverse(components)(_.allSources)().flatten }\n\n  /** Aggreagted resources from all component modules */\n  def aggregatedResources = T { T.traverse(components)(_.resources)().flatten }\n\n  /** Aggreagted compile resources from all component modules */\n  def aggregatedCompileResources = T { T.traverse(components)(_.compileResources)().flatten }\n\n  /** Aggregated sourceJar from all component modules\n    */\n  override def sourceJar: T[PathRef] = T {\n    // This is based on the implementation of sourceJar in PublishModule, may need to be kept in sync.\n    val allDirs = aggregatedSources() ++ aggregatedResources() ++ aggregatedCompileResources()\n    createJar(allDirs.map(_.path).filter(os.exists), manifest())\n  }\n\n  // Needed for ScalaDoc\n  override def scalacOptions = v.scala2CommonOptions\n\n  def scalaDocRootDoc = T.source { T.workspace / \"root-doc.txt\" }\n\n  def unidocOptions = T {\n    scalacOptions() ++ Seq[String](\n      \"-classpath\",\n      unidocCompileClasspath().map(_.path).mkString(sys.props(\"path.separator\")),\n      \"-diagrams\",\n      \"-groups\",\n      \"-skip-packages\",\n      \"chisel3.internal\",\n      \"-diagrams-max-classes\",\n      \"25\",\n      \"-doc-version\",\n      publishVersion(),\n      \"-doc-title\",\n      \"chisel\",\n      \"-doc-root-content\",\n      scalaDocRootDoc().path.toString,\n      \"-sourcepath\",\n      T.workspace.toString,\n      \"-doc-source-url\",\n      unidocSourceUrl(),\n      \"-language:implicitConversions\",\n      \"-implicits\"\n    )\n  }\n\n  // Built-in UnidocModule is insufficient so we need to implement it ourselves\n  // We could factor this out into a utility\n  def unidocSourceUrl: T[String] = T {\n    val base = \"https://github.com/chipsalliance/chisel/tree\"\n    val branch = if (publishVersion().endsWith(\"-SNAPSHOT\")) \"main\" else s\"v${publishVersion()}\"\n    s\"$base/$branch/€{FILE_PATH_EXT}#L€{FILE_LINE}\"\n  }\n\n  def unidocVersion: T[Option[String]] = None\n\n  def unidocCompileClasspath = T {\n    Seq(compile().classes) ++ T.traverse(components)(_.compileClasspath)().flatten\n  }\n\n  def unidocSourceFiles = T {\n    allSourceFiles() ++ T.traverse(components)(_.allSourceFiles)().flatten\n  }\n\n  // Based on UnidocModule and docJar in Mill, may need to be kept in sync.\n  override def docJar = T {\n    T.log.info(s\"Building unidoc for ${unidocSourceFiles().length} files\")\n\n    val javadocDir = T.dest / \"javadoc\"\n    os.makeDir(javadocDir)\n\n    val fullOptions = unidocOptions() ++\n      Seq(\"-d\", javadocDir.toString) ++\n      unidocSourceFiles().map(_.path.toString)\n\n    zincWorker()\n      .worker()\n      .docJar(\n        scalaVersion(),\n        scalaOrganization(),\n        scalaDocClasspath(),\n        scalacPluginClasspath(),\n        fullOptions\n      ) match {\n      case true  => Result.Success(createJar(Agg(javadocDir))(T.dest))\n      case false => Result.Failure(\"docJar generation failed\")\n    }\n  }\n}\n"
            ],
            [
                "/home/runner/work/opengpu/opengpu/depends/arithmetic/common.sc",
                "import mill._\nimport mill.scalalib._\nimport mill.scalalib.publish._\nimport coursier.maven.MavenRepository\n\ntrait HasChisel\n  extends ScalaModule {\n  // Define these for building chisel from source\n  def chiselModule: Option[ScalaModule]\n\n  override def moduleDeps = super.moduleDeps ++ chiselModule\n\n  def chiselPluginJar: T[Option[PathRef]]\n\n  override def scalacOptions = T(super.scalacOptions() ++ chiselPluginJar().map(path => s\"-Xplugin:${path.path}\"))\n\n  override def scalacPluginClasspath: T[Agg[PathRef]] = T(super.scalacPluginClasspath() ++ chiselPluginJar())\n\n  // Define these for building chisel from ivy\n  def chiselIvy: Option[Dep]\n\n  override def ivyDeps = T(super.ivyDeps() ++ chiselIvy)\n\n  def chiselPluginIvy: Option[Dep]\n\n  override def scalacPluginIvyDeps: T[Agg[Dep]] = T(super.scalacPluginIvyDeps() ++ chiselPluginIvy.map(Agg(_)).getOrElse(Agg.empty[Dep]))\n}\n\ntrait ArithmeticModule\n  extends ScalaModule\n    with HasChisel {\n  def spireIvy: T[Dep]\n\n  def evilplotIvy: T[Dep]\n\n  override def ivyDeps = T(super.ivyDeps() ++ Seq(spireIvy(), evilplotIvy()))\n}\n"
            ],
            [
                "/home/runner/work/opengpu/opengpu/depends/chisel/panama.sc",
                "import mill._\nimport mill.scalalib._\nimport mill.api.Result\nimport mill.scalalib._\nimport mill.scalalib.api.CompilationResult\nimport mill.util.Jvm\nimport mill.scalalib.scalafmt._\n\nimport java.util\nimport scala.jdk.StreamConverters.StreamHasToScala\n\nobject utils extends Module {\n  val architecture = System.getProperty(\"os.arch\")\n  val operationSystem = System.getProperty(\"os.name\")\n\n  val mac = operationSystem.toLowerCase.startsWith(\"mac\")\n  val linux = operationSystem.toLowerCase.startsWith(\"linux\")\n  val windows = operationSystem.toLowerCase.startsWith(\"win\")\n  val amd64 = architecture.matches(\"^(x8664|amd64|ia32e|em64t|x64|x86_64)$\")\n  val aarch64 = architecture.equals(\"aarch64\") | architecture.startsWith(\"armv8\")\n\n  val firtoolVersion = {\n    val j = _root_.upickle.default.read[Map[String, String]](os.read(millSourcePath / os.up / \"etc\" / \"circt.json\"))\n    j(\"version\").stripPrefix(\"firtool-\")\n  }\n\n  def circt(version: String, os: String, platform: String) =\n    s\"https://github.com/llvm/circt/releases/download/firtool-${version}/circt-full-shared-${os}-${platform}.tar.gz\"\n\n  // 21, 1-2, {linux-x64, macos-x64, windows-x64}\n  // 22, 1-2, {linux-x64, macos-aarch64, macos-x64, windows-x64}\n  def jextract(jdkVersion: Int, jextractVersion: String, os: String, platform: String) =\n    s\"https://download.java.net/java/early_access/jextract/21/1/openjdk-${jdkVersion}-jextract+${jextractVersion}_${os}-${platform}_bin.tar.gz\"\n\n  // use T.persistent to avoid download repeatedly\n  def circtInstallDir: T[os.Path] = T.persistent {\n    T.ctx().env.get(\"CIRCT_INSTALL_PATH\") match {\n      case Some(dir) => os.Path(dir)\n      case None =>\n        T.ctx().log.info(\"Use CIRCT_INSTALL_PATH to vendor circt\")\n        val tarPath = T.dest / \"circt.tar.gz\"\n        if (!os.exists(tarPath)) {\n          val url = circt(\n            firtoolVersion,\n            if (linux) \"linux\" else if (mac) \"macos\" else throw new Exception(\"unsupported os\"),\n            // circt does not yet publish for macos-aarch64, use x64 for now\n            if (amd64 || mac) \"x64\" else throw new Exception(\"unsupported arch\")\n          )\n          T.ctx().log.info(s\"Downloading circt from ${url}\")\n          mill.util.Util.download(url, os.rel / \"circt.tar.gz\")\n          T.ctx().log.info(s\"Download Successfully\")\n        }\n        os.proc(\"tar\", \"xvf\", tarPath, \"--strip-components=1\").call(T.dest)\n        T.dest\n    }\n  }\n\n  // use T.persistent to avoid download repeatedly\n  def jextractInstallDir: T[os.Path] = T.persistent {\n    T.ctx().env.get(\"JEXTRACT_INSTALL_PATH\") match {\n      case Some(dir) => os.Path(dir)\n      case None =>\n        T.ctx().log.info(\"Use JEXTRACT_INSTALL_PATH to vendor jextract\")\n        val tarPath = T.dest / \"jextract.tar.gz\"\n        if (!os.exists(tarPath)) {\n          val url = jextract(\n            21,\n            \"1-2\",\n            if (linux) \"linux\" else if (mac) \"macos\" else throw new Exception(\"unsupported os\"),\n            // There is no macos-aarch64 for jextract 21, use x64 for now\n            if (amd64 || mac) \"x64\" else if (aarch64) \"aarch64\" else throw new Exception(\"unsupported arch\")\n          )\n          T.ctx().log.info(s\"Downloading jextract from ${url}\")\n          mill.util.Util.download(url, os.rel / \"jextract.tar.gz\")\n          T.ctx().log.info(s\"Download Successfully\")\n        }\n        os.proc(\"tar\", \"xvf\", tarPath, \"--strip-components=1\").call(T.dest)\n        T.dest\n    }\n  }\n}\n\ntrait HasJextractGeneratedSources extends JavaModule {\n\n  def jextractBinary: T[os.Path]\n\n  def includePaths: T[Seq[PathRef]]\n\n  def libraryPaths: T[Seq[PathRef]]\n\n  def header: T[PathRef]\n\n  def includeFunctions: T[Seq[String]]\n\n  def includeConstants: T[Seq[String]]\n\n  def includeStructs: T[Seq[String]]\n\n  def includeTypedefs: T[Seq[String]]\n\n  def includeUnions: T[Seq[String]]\n\n  def includeVars: T[Seq[String]]\n\n  def linkLibraries: T[Seq[String]]\n\n  def target: T[String]\n\n  def headerClassName: T[String]\n\n  def dumpAllIncludes = T {\n    val f = os.temp()\n    os.proc(\n      Seq(jextractBinary().toString, header().path.toString)\n        ++ includePaths().flatMap(p => Seq(\"-I\", p.path.toString))\n        ++ Seq(\"--dump-includes\", f.toString)\n    ).call()\n    os.read.lines(f).filter(s => s.nonEmpty && !s.startsWith(\"#\"))\n  }\n\n  override def generatedSources: T[Seq[PathRef]] = T {\n    super.generatedSources() ++ {\n      // @formatter:off\n      os.proc(\n        Seq(jextractBinary().toString, header().path.toString)\n          ++ includePaths().flatMap(p => Seq(\"-I\", p.path.toString))\n          ++ Seq(\n            \"-t\", target(),\n            \"--header-class-name\", headerClassName(),\n            \"--source\",\n            \"--output\", T.dest.toString\n          ) ++ includeFunctions().flatMap(f => Seq(\"--include-function\", f)) ++\n          includeConstants().flatMap(f => Seq(\"--include-constant\", f)) ++\n          includeStructs().flatMap(f => Seq(\"--include-struct\", f)) ++\n          includeTypedefs().flatMap(f => Seq(\"--include-typedef\", f)) ++\n          includeUnions().flatMap(f => Seq(\"--include-union\", f)) ++\n          includeVars().flatMap(f => Seq(\"--include-var\", f)) ++\n          linkLibraries().flatMap(l => Seq(\"-l\", l))\n      ).call(T.dest)\n      // @formatter:on\n      Seq(PathRef(T.dest))\n    }\n  }\n\n  override def javacOptions = T(super.javacOptions() ++ Seq(\"--enable-preview\", \"--release\", \"21\"))\n}\n\n// Java Codegen for all declared functions.\n// All of these functions are not private API which is subject to change.\ntrait CIRCTPanamaBindingModule extends HasJextractGeneratedSources {\n\n  def includeConstants =\n    T.input(os.read.lines(millSourcePath / \"includeConstants.txt\").filter(s => s.nonEmpty && !s.startsWith(\"#\")))\n  def includeFunctions =\n    T.input(os.read.lines(millSourcePath / \"includeFunctions.txt\").filter(s => s.nonEmpty && !s.startsWith(\"#\")))\n  def includeStructs =\n    T.input(os.read.lines(millSourcePath / \"includeStructs.txt\").filter(s => s.nonEmpty && !s.startsWith(\"#\")))\n  def includeTypedefs =\n    T.input(os.read.lines(millSourcePath / \"includeTypedefs.txt\").filter(s => s.nonEmpty && !s.startsWith(\"#\")))\n  def includeUnions =\n    T.input(os.read.lines(millSourcePath / \"includeUnions.txt\").filter(s => s.nonEmpty && !s.startsWith(\"#\")))\n  def includeVars =\n    T.input(os.read.lines(millSourcePath / \"includeVars.txt\").filter(s => s.nonEmpty && !s.startsWith(\"#\")))\n  def linkLibraries =\n    T.input(os.read.lines(millSourcePath / \"linkLibraries.txt\").filter(s => s.nonEmpty && !s.startsWith(\"#\")))\n\n  def target = T(\"org.llvm.circt\")\n  def headerClassName = T(\"CAPI\")\n}\n\ntrait HasCIRCTPanamaBindingModule extends JavaModule {\n  def circtPanamaBindingModule: CIRCTPanamaBindingModule\n\n  override def moduleDeps = super.moduleDeps ++ Some(circtPanamaBindingModule)\n  //\n  override def javacOptions = T(super.javacOptions() ++ Seq(\"--enable-preview\", \"--release\", \"21\"))\n\n  override def forkArgs: T[Seq[String]] = T(\n    super.forkArgs() ++ Seq(\"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\")\n      ++ circtPanamaBindingModule\n        .libraryPaths()\n        .map(p => s\"-Djava.library.path=${p.path}\")\n  )\n}\n\n// The Scala API for PanamaBinding, API here is experimentally public to all developers\ntrait PanamaLibModule extends ScalaModule with HasCIRCTPanamaBindingModule\n\ntrait HasPanamaLibModule extends ScalaModule with HasCIRCTPanamaBindingModule {\n  def panamaLibModule: PanamaLibModule\n\n  def circtPanamaBindingModule = panamaLibModule.circtPanamaBindingModule\n\n  override def moduleDeps = super.moduleDeps ++ Some(panamaLibModule)\n}\n\ntrait PanamaOMModule extends ScalaModule with HasPanamaLibModule\n\ntrait HasPanamaOMModule extends ScalaModule with HasCIRCTPanamaBindingModule {\n  def panamaOMModule: PanamaOMModule\n\n  def circtPanamaBindingModule = panamaOMModule.circtPanamaBindingModule\n\n  override def moduleDeps = super.moduleDeps ++ Some(panamaOMModule)\n}\n\ntrait PanamaConverterModule extends ScalaModule with HasPanamaOMModule\n\ntrait HasPanamaConverterModule extends ScalaModule with HasCIRCTPanamaBindingModule {\n  def panamaConverterModule: PanamaConverterModule\n\n  def circtPanamaBindingModule = panamaConverterModule.circtPanamaBindingModule\n\n  override def moduleDeps = super.moduleDeps ++ Some(panamaConverterModule)\n}\n\ntrait PanamaOM extends PanamaOMModule with CrossModuleBase with ScalafmtModule\n\ntrait LitUtilityModule extends ScalaModule with HasPanamaConverterModule with HasPanamaOMModule {\n  override def scalacOptions = T { Seq(\"-Ymacro-annotations\") }\n  override def circtPanamaBindingModule = panamaConverterModule.circtPanamaBindingModule\n}\n\ntrait LitModule extends Module {\n  def scalaVersion:    T[String]\n  def runClasspath:    T[Seq[os.Path]]\n  def pluginJars:      T[Seq[os.Path]]\n  def javaLibraryPath: T[Seq[os.Path]]\n  def javaHome:        T[os.Path]\n  def chiselLitDir:    T[os.Path]\n  def litConfigIn:     T[PathRef]\n  def litConfig: T[PathRef] = T {\n    os.write(\n      T.dest / \"lit.site.cfg.py\",\n      os.read(litConfigIn().path)\n        .replaceAll(\"@SCALA_VERSION@\", scalaVersion())\n        .replaceAll(\"@RUN_CLASSPATH@\", runClasspath().mkString(\",\"))\n        .replaceAll(\"@SCALA_PLUGIN_JARS@\", pluginJars().mkString(\",\"))\n        .replaceAll(\"@JAVA_HOME@\", javaHome().toString)\n        .replaceAll(\"@JAVA_LIBRARY_PATH@\", javaLibraryPath().mkString(\",\"))\n        .replaceAll(\"@CHISEL_LIT_DIR@\", chiselLitDir().toString)\n    )\n    PathRef(T.dest)\n  }\n  def run(args: String*) = T.command(\n    os.proc(\"lit\", litConfig().path)\n      .call(T.dest, stdout = os.ProcessOutput.Readlines(line => T.ctx().log.info(\"[lit] \" + line)))\n  )\n}\n"
            ],
            [
                "/home/runner/work/opengpu/opengpu/depends/chisel-interface/common.sc",
                "import mill._\nimport mill.scalalib._\n\ntrait HasChisel extends ScalaModule {\n  // Define these for building chisel from source\n  def chiselModule: Option[ScalaModule] = None\n\n  override def moduleDeps = super.moduleDeps ++ chiselModule\n\n  def chiselPluginJar: T[Option[PathRef]] = None\n\n  override def scalacOptions = T(\n    super.scalacOptions() ++ chiselPluginJar().map(path =>\n      s\"-Xplugin:${path.path}\"\n    ) ++ Seq(\"-Ymacro-annotations\")\n  )\n\n  override def scalacPluginClasspath: T[Agg[PathRef]] = T(\n    super.scalacPluginClasspath() ++ chiselPluginJar()\n  )\n\n  // Define these for building chisel from ivy\n  def chiselIvy: Option[Dep] = None\n\n  override def ivyDeps = T(super.ivyDeps() ++ chiselIvy)\n\n  def chiselPluginIvy: Option[Dep] = None\n\n  override def scalacPluginIvyDeps: T[Agg[Dep]] = T(\n    super.scalacPluginIvyDeps() ++ chiselPluginIvy\n      .map(Agg(_))\n      .getOrElse(Agg.empty[Dep])\n  )\n}\n\ntrait ChiselInterfaceModule extends HasChisel {\n  // Use for elaboration.\n  def mainargsIvy: Dep\n  override def ivyDeps = T(super.ivyDeps() ++ Some(mainargsIvy))\n}\n\ntrait DWBBModule extends ChiselInterfaceModule\n\ntrait AXI4Module extends ChiselInterfaceModule\n\ntrait JTAGModule extends ChiselInterfaceModule\n"
            ],
            [
                "/home/runner/work/opengpu/opengpu/depends/rvdecoderdb/common.sc",
                "// SPDX-License-Identifier: Apache-2.0\n// SPDX-FileCopyrightText: 2022 Jiuyang Liu <liu@jiuyang.me>\n\nimport mill._\nimport mill.scalalib._\nimport mill.scalajslib._\n\ntrait RVDecoderDBJVMModule extends ScalaModule {\n  override def sources: T[Seq[PathRef]] = T.sources { super.sources() ++ Some(PathRef(millSourcePath / \"jvm\" / \"src\"))  }\n  def osLibIvy: Dep\n  def upickleIvy: Dep\n  override def ivyDeps = super.ivyDeps() ++ Some(osLibIvy) ++ Some(upickleIvy)\n}\n\ntrait HasRVDecoderDBResource extends ScalaModule {\n  def riscvOpcodesPath: T[Option[PathRef]] = T(None)\n  def riscvOpcodesTar: T[Option[PathRef]] = T {\n    riscvOpcodesPath().map { riscvOpcodesPath =>\n      val tmpDir = os.temp.dir()\n      os.makeDir(tmpDir / \"unratified\")\n      os.walk(riscvOpcodesPath.path)\n        .filter(f =>\n          f.baseName.startsWith(\"rv128_\") ||\n            f.baseName.startsWith(\"rv64_\") ||\n            f.baseName.startsWith(\"rv32_\") ||\n            f.baseName.startsWith(\"rv_\") ||\n            f.ext == \"csv\"\n        ).groupBy(_.segments.contains(\"unratified\")).map {\n            case (true, fs) => fs.map(os.copy.into(_, tmpDir / \"unratified\"))\n            case (false, fs) => fs.map(os.copy.into(_, tmpDir))\n          }\n      os.proc(\"tar\", \"cf\", T.dest / \"riscv-opcodes.tar\", \".\").call(tmpDir)\n      PathRef(T.dest)\n    }\n  }\n  override def resources: T[Seq[PathRef]] = super.resources() ++ riscvOpcodesTar()\n}\n\ntrait RVDecoderDBJVMTestModule extends HasRVDecoderDBResource with ScalaModule {\n  override def sources: T[Seq[PathRef]] = T.sources { super.sources() ++ Some(PathRef(millSourcePath / \"jvm\" / \"src\"))  }\n  def dut: RVDecoderDBJVMModule\n  override def moduleDeps = super.moduleDeps ++ Some(dut)\n}\n\ntrait RVDecoderDBJSModule extends ScalaJSModule {\n  override def sources: T[Seq[PathRef]] = T.sources { super.sources() ++ Some(PathRef(millSourcePath / \"js\" / \"src\"))  }\n  def upickleIvy: Dep\n  override def ivyDeps = super.ivyDeps() ++ Some(upickleIvy)\n}\n\ntrait RVDecoderDBTestJSModule extends ScalaJSModule {\n  override def sources: T[Seq[PathRef]] = T.sources { super.sources() ++ Some(PathRef(millSourcePath / \"js\" / \"src\"))  }\n  def dut: RVDecoderDBJSModule\n  override def moduleDeps = super.moduleDeps ++ Some(dut)\n}\n"
            ]
        ],
        "repos": [],
        "ivyDeps": [
            "io.chris-kipp::mill-ci-release::0.1.10",
            "com.lihaoyi::mill-contrib-jmh:"
        ],
        "importGraphEdges": [
            [
                "/home/runner/work/opengpu/opengpu/depends/hardfloat/common.sc",
                []
            ],
            [
                "/home/runner/work/opengpu/opengpu/common.sc",
                []
            ],
            [
                "/home/runner/work/opengpu/opengpu/depends/diplomacy/common.sc",
                []
            ],
            [
                "/home/runner/work/opengpu/opengpu/depends/rocket-chip/common.sc",
                []
            ],
            [
                "/home/runner/work/opengpu/opengpu/depends/cde/common.sc",
                []
            ],
            [
                "/home/runner/work/opengpu/opengpu/build.sc",
                [
                    "/home/runner/work/opengpu/opengpu/depends/chisel/build.sc",
                    "/home/runner/work/opengpu/opengpu/depends/arithmetic/common.sc",
                    "/home/runner/work/opengpu/opengpu/depends/chisel-interface/common.sc",
                    "/home/runner/work/opengpu/opengpu/depends/hardfloat/common.sc",
                    "/home/runner/work/opengpu/opengpu/depends/rvdecoderdb/common.sc",
                    "/home/runner/work/opengpu/opengpu/depends/rocket-chip/common.sc",
                    "/home/runner/work/opengpu/opengpu/depends/cde/common.sc",
                    "/home/runner/work/opengpu/opengpu/depends/diplomacy/common.sc",
                    "/home/runner/work/opengpu/opengpu/common.sc"
                ]
            ],
            [
                "/home/runner/work/opengpu/opengpu/depends/chisel/build.sc",
                [
                    "/home/runner/work/opengpu/opengpu/depends/chisel/panama.sc"
                ]
            ],
            [
                "/home/runner/work/opengpu/opengpu/depends/arithmetic/common.sc",
                []
            ],
            [
                "/home/runner/work/opengpu/opengpu/depends/chisel/panama.sc",
                []
            ],
            [
                "/home/runner/work/opengpu/opengpu/depends/chisel-interface/common.sc",
                []
            ],
            [
                "/home/runner/work/opengpu/opengpu/depends/rvdecoderdb/common.sc",
                []
            ]
        ],
        "errors": [],
        "millImport": false
    },
    "valueHash": -1560803376,
    "inputsHash": -1031045344
}